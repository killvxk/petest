// PETest.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "PEUtil.h"

// 加载 load.dll 并调用函数DoAction
byte a_code[] = {
	0x55,0x8b,0xec,0x81,0xec,0xb0,0x00,0x00,0x00,0x53,0x56,0x57,0xc7,0x45,0xfc,
	0x72,0x6f,0x63,0x41,0xc7,0x45,0xf8,0x00,0x00,0x00,0x00,0xc7,0x45,0xf4,0x00,
	0x00,0x00,0x00,0xc7,0x45,0xf0,0x00,0x00,0x00,0x00,0xc7,0x45,0xec,0x00,0x00,
	0x00,0x00,0xc6,0x45,0xdc,0x4c,0xc6,0x45,0xdd,0x6f,0xc6,0x45,0xde,0x61,0xc6,
	0x45,0xdf,0x64,0xc6,0x45,0xe0,0x4c,0xc6,0x45,0xe1,0x69,0xc6,0x45,0xe2,0x62,
	0xc6,0x45,0xe3,0x72,0xc6,0x45,0xe4,0x61,0xc6,0x45,0xe5,0x72,0xc6,0x45,0xe6,
	0x79,0xc6,0x45,0xe7,0x41,0xc6,0x45,0xe8,0x00,0x33,0xc0,0x66,0x89,0x45,0xe9,
	0x88,0x45,0xeb,0xc6,0x45,0xcc,0x6c,0xc6,0x45,0xcd,0x6f,0xc6,0x45,0xce,0x61,
	0xc6,0x45,0xcf,0x64,0xc6,0x45,0xd0,0x2e,0xc6,0x45,0xd1,0x64,0xc6,0x45,0xd2,
	0x6c,0xc6,0x45,0xd3,0x6c,0xc6,0x45,0xd4,0x00,0x33,0xc0,0x89,0x45,0xd5,0x66,
	0x89,0x45,0xd9,0x88,0x45,0xdb,0xc6,0x45,0xbc,0x44,0xc6,0x45,0xbd,0x6f,0xc6,
	0x45,0xbe,0x41,0xc6,0x45,0xbf,0x63,0xc6,0x45,0xc0,0x74,0xc6,0x45,0xc1,0x69,
	0xc6,0x45,0xc2,0x6f,0xc6,0x45,0xc3,0x6e,0xc6,0x45,0xc4,0x00,0x33,0xc0,0x89,
	0x45,0xc5,0x66,0x89,0x45,0xc9,0x88,0x45,0xcb,0x50,0x64,0xa1,0x30,0x00,0x00,
	0x00,0x8b,0x40,0x0c,0x8b,0x40,0x0c,0x8b,0x00,0x8b,0x00,0x8b,0x40,0x18,0x89,
	0x45,0xec,0x58,0x8b,0x45,0xec,0x89,0x45,0xb8,0x8b,0x45,0xb8,0x8b,0x4d,0xec,
	0x03,0x48,0x3c,0x89,0x4d,0xb4,0x8b,0x45,0xb4,0x83,0xc0,0x18,0x89,0x45,0xb0,
	0xb8,0x08,0x00,0x00,0x00,0x6b,0xc8,0x00,0x8b,0x55,0xb0,0x8b,0x45,0xec,0x03,
	0x44,0x0a,0x60,0x89,0x45,0xac,0x8b,0x45,0xac,0x8b,0x4d,0xec,0x03,0x48,0x20,
	0x89,0x4d,0xa8,0x8b,0x45,0xac,0x8b,0x4d,0xec,0x03,0x48,0x24,0x89,0x4d,0xa4,
	0x8b,0x45,0xac,0x8b,0x4d,0xec,0x03,0x48,0x1c,0x89,0x4d,0xa0,0xc7,0x45,0x9c,
	0x00,0x00,0x00,0x00,0xeb,0x09,0x8b,0x45,0x9c,0x83,0xc0,0x01,0x89,0x45,0x9c,
	0x8b,0x45,0xac,0x8b,0x4d,0x9c,0x3b,0x48,0x14,0x73,0x3c,0x8b,0x45,0x9c,0x8b,
	0x4d,0xa8,0x8b,0x55,0xec,0x03,0x14,0x81,0x89,0x55,0xf4,0xb8,0x04,0x00,0x00,
	0x00,0xc1,0xe0,0x00,0x8b,0x4d,0xf4,0x8b,0x14,0x01,0x3b,0x55,0xfc,0x75,0x18,
	0x8b,0x45,0x9c,0x8b,0x4d,0xa4,0x0f,0xb7,0x14,0x41,0x8b,0x45,0xa0,0x8b,0x4d,
	0xec,0x03,0x0c,0x90,0x89,0x4d,0xf8,0xeb,0x02,0xeb,0xb0,0x83,0x7d,0xf8,0x00,
	0x75,0x02,0xeb,0x39,0x8d,0x45,0xdc,0x50,0x8b,0x4d,0xec,0x51,0xff,0x55,0xf8,
	0x89,0x45,0x98,0x8d,0x45,0xcc,0x50,0xff,0x55,0x98,0x89,0x45,0x94,0x83,0x7d,
	0x94,0x00,0x75,0x02,0xeb,0x19,0x8d,0x45,0xbc,0x50,0x8b,0x4d,0x94,0x51,0xff,
	0x55,0xf8,0x89,0x45,0x90,0x83,0x7d,0x90,0x00,0x75,0x02,0xeb,0x03,0xff,0x55,
	0x90,0x5f,0x5e,0x5b,0x8b,0xe5,0x5d,//0xc3,

	0xe9,0x00,0x00,0x00,0x00,// jmp 
};

// a_code 原形

typedef WINBASEAPI FARPROC(WINAPI *fnGetProcAddress)(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
typedef WINBASEAPI HMODULE(WINAPI *fnLoadLibraryA)(_In_ LPCSTR lpLibFileName);

void __stdcall GetProcAddr()
{
	DWORD dwMatch = 0x41636f72;//'rocA'
	fnGetProcAddress pGetProcAddress = NULL;
	DWORD* szName = NULL;
	DWORD j = 0;
	char* pKernelBase = NULL;
	char szLL[16] = { 'L','o','a','d','L','i','b','r','a','r','y','A','\0' };
	char szDllName[16] = { 'l','o','a','d','.','d','l','l','\0' };
	char szDllFun[16] = { 'D','o','A','c','t','i','o','n','\0' };

	__asm
	{
		push eax;
		mov eax, dword ptr fs : [0x30];
		mov eax, dword ptr[eax + 0xC];
		mov eax, dword ptr[eax + 0xC];
		mov eax, dword ptr[eax];
		mov eax, dword ptr[eax];
		mov eax, dword ptr[eax + 0x18];
		mov pKernelBase, eax;
		pop eax;
	}

	IMAGE_DOS_HEADER* pDos = (IMAGE_DOS_HEADER*)pKernelBase;
	IMAGE_NT_HEADERS* pNT = PIMAGE_NT_HEADERS(pKernelBase + pDos->e_lfanew);
	IMAGE_OPTIONAL_HEADER* pOp = &pNT->OptionalHeader;
	IMAGE_EXPORT_DIRECTORY* pExp = (IMAGE_EXPORT_DIRECTORY*)(pKernelBase + pOp->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
	DWORD* pName = (DWORD*)(pKernelBase + pExp->AddressOfNames);
	WORD* pOrg = (WORD*)(pKernelBase + pExp->AddressOfNameOrdinals);
	DWORD* pProc = (DWORD*)(pKernelBase + pExp->AddressOfFunctions);

	for (DWORD i = 0; i < pExp->NumberOfFunctions; i++)
	{
		szName = (DWORD*)(pKernelBase + pName[i]);
		if (szName[1] == dwMatch)
		{
			pGetProcAddress = fnGetProcAddress(pKernelBase + pProc[pOrg[i]]);
			break;
		}
	}

	if (!pGetProcAddress)
		return;

	fnLoadLibraryA pLoadLibraryA = (fnLoadLibraryA)pGetProcAddress((HMODULE)pKernelBase, szLL);
	HMODULE hMod = pLoadLibraryA(szDllName);
	if (!hMod) return;
	FARPROC pCall = pGetProcAddress(hMod, szDllFun);
	if (!pCall) return;
	__asm
	{
		call pCall;
	}
}



int main(int argc, const char** argv)
{
	if (argc < 2)
		return 0;

	CPEUtil peUtil;

	if (peUtil.Load(CA2T(argv[1])))
	{
		//peUtil.AddCode(a_code, sizeof(a_code));
		peUtil.AddImportTable("load.dll", "DoAction");
		cout << "add result: " << peUtil.Save(_T("new.add.exe")) << endl;
	}
	else
	{
		cout << "error load file: " << argv[1] << endl;
	}

    return 0;
}

